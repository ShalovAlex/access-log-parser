Жизненный цикл стрима

создание стрима,
применение к стриму ряда промежуточных операций,
применение к стриму завершающей операции с целью получения ожидаемого результата.

С созданием стрима мы разобрались. Теперь нужно разобраться с операциями, которые мы можем применять к нему.
Операции делятся на 2 типа: промежуточные и терминальные.
Промежуточные — это операции, которые возвращают изменённый стрим (стрим, к которому применили определенные действия).
К возвращённому стриму можно применить несколько промежуточных операций.
Далее идет последняя операция, которая возвращает нам конкретный ожидаемый результат, — терминальная.
Такая операция у стрима одна и она завершает его жизненный цикл.

промежуточные операторы:
Stream<T> of() - Создаёт поток из набора объектов
Stream<T> generate() - Генерирует поток по заданному правилу
Stream<T> concat() - Объединяет несколько потоков в один
Stream<T> filter() - Фильтрует данные. Оставляет данные, подходящие под описанное правило.
Stream<T> distinct() - Удаляет дубликаты
Stream<T> sorted() - Сортирует данные
Stream<T> peek() - Выполняет определённое действие над каждым элементом
Stream<T> limit(n) - Обрезает данные после достижения лимита
Stream<T> skip(n) - Пропускает первые n элементов
Stream<T> map() - Преобразует данные из одного типа в другой
Stream<T> flatMap() - Преобразует данные из одного типа в другой (немного иначе, чем просто map)

Терминальные операторы:
boolean anyMatch() - Проверяет элементы потока на совпадение заданному правилу хотя бы одного
boolean allMatch() - Проверяет все элементы потока на совпадение заданному правилу
boolean noneMatch() - Проверяет все элементы потока на НЕсовпадение заданному правилу
*Optional<T> findFirst() - Возвращает первый соответствующий правилу элемент
*Optional<T> findAny() - Возвращает любой соответствующий правилу элемент
*Optional<T> min() - Ищет минимальный элемент в потоке
*Optional<T> max() - Ищет максимальный элемент в потоке
long count() - Возвращает количество элементов в потоке
R collect() - Все данные из потока возвращаются в виде коллекции

* В некоторых методах возвращается Optional<T>. Optional — служебный класс.
Его задача — просто хранить в себе ссылку на объект типа T.
При этом ссылка на объект внутри класса Optional<T> может быть и null.
Класс Optional позволяет «красиво» проверять на null и описывать, что делать, если внутри хранится null.


Самое интересное: зачем нам нужны стримы и почему они выигрывают коллекции по нескольким пунктам.
1) Стримы не хранят элементы. Элементы, используемые в стримах, могут храниться в коллекции,
либо при необходимости могут быть напрямую сгенерированы.
2) Операции со стримами не изменяют источник данных, а лишь возвращают новый стрим с результатами этих операций.
3) Для стримов характерно отложенное выполнение. Все операции со стримом происходят лишь тогда,
когда выполняется терминальная операция и возвращается конкретный результат, а не новый стрим.
Важно понимать, что Stream API — очень важное и нужное обновление,
которое несёт за собой большее удобство со стороны разработки, улучшение производительности и работы с памятью.
Используется повсеместно.
Вместе с выходом Stream API было ещё одно важное обновление, связанное с реализацией функциональных интерфейсов.

Функциональные интерфейсы
Очень часто при построении архитектуры выделяют интерфейсы с единственной ответственностью (единственным методом).
Такие интерфейсы обычно несут ответственность за реализацию этого единственного функционала.
Например, есть задача «научить» класс что-то делать. Это действие выделено в отдельный интерфейс.
@FunctionalInterface
interface Testable<T> {
   boolean test(T value);
}
В данном интерфейсе, который содержит контракт на тестирование, есть единственный абстрактный метод test(),
который принимает аргумент и возвращает boolean.
Из-за того, что вся логика этого интерфейса определена одним единственным методом,
он называется функциональным интерфейсом. Мы можем поставить ему аннотацию @FunctionalInterface

Лямбда-выражение представляет собой набор инструкций (кусок кода), который можно:
1) сохранить в переменную (ссылочную),
2) передать в качестве аргумента в метод,
3) вызвать в любой момент времени,
4) использовать несколько раз.
По факту, лямбд-выражение — это упрощённая запись анонимного класса, который реализует функциональный интерфейс.
Синтаксис лямбда-выражений:
( параметры ) -> { тело метода }

функциональные интерфейсы
Predicate - Проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true.
            В качестве параметра лямбда-выражение принимает объект типа T.
Consumer - Выполняет некоторое действие над объектом типа T, при этом ничего не возвращая.
Function - Представляет функцию перехода от объекта типа T к объекту типа R.
Supplier - Не принимает никаких аргументов, но возвращает объект типа T.